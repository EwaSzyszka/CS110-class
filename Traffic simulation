import numpy as np
from random import randint
%matplotlib inline
import matplotlib.pyplot as plt

class Trafficsimulation:

    def __init__(self, road_length, density, max_velo, prob_slow_down):

        self.road_length = road_length
        self.density = density
        self.max_velo = max_velo
        self.prob_slow_down = prob_slow_down
        self.lists = [-1] * road_length
        self.next_step = []*road_length

    def assignfirstStates(self):
        for i in range(self.density):
            self.lists[i] = randint(0, self.max_velo)
        np.random.shuffle(self.lists) #put the new values in random positions
        return self.lists
    
    
    def updateRule(self):
        
        distances = []
        for i in range(len(self.lists)):
            if self.lists[i] != -1:
                count = i + 1
                while self.lists[count % self.road_length]== -1 :
                    count +=1
                distance = (count - i)-1
            else:
                distance = -1
            distances.append(distance)
        print ("Initial velocities", self.lists)
        plt.imshow([self.lists], aspect= 'equal', interpolation='none',origin='lower')
        plt.show()
        print ("Distances",distances)
        
        
        new_velocity = []
        for i in range(len(distances)):
              
            if distances[i]== -1:
                new_velocity.append(-1) 
            elif distances[i]==0:
                new_velocity.append(0) 
            elif distances[i]> self.lists[i]:
                if self.max_velo > self.lists[i]:
                    new_velocity.append(self.lists[i]+1)
                else:
                    new_velocity.append(self.lists[i])
            elif distances[i]<self.lists[i]:
                new_velocity.append(distances[i])   
            elif distances[i] == self.lists[i]:
                new_velocity.append(self.lists[i])
    
        print ("New velocities", new_velocity) 
        
        next_step = [-1]*len(new_velocity) 
        for i in range(len(new_velocity)):

            if new_velocity[i] != -1:
                next_step[(new_velocity[i]+ i)%len(new_velocity)]  = new_velocity[i]
            
        print ("Next step", next_step)
        plt.imshow([next_step], aspect= 'equal', interpolation='none',origin='lower')
        plt.show()
        print (''.join('.' if x == -1  else str(x)  for x  in next_step))
        return next_step

        
    def assignStates(self, next_step):
        for i in range(len(next_step)):
            self.lists[i] = next_step[i]
        return self.lists
        

sim1 = Trafficsimulation(10,2,5,0.5)
sim1.assignfirstStates()
sim1.lists = [-1, 3, -1, 1, -1, -1, -1, -1, -1, -1]
for i in range(10):
    x = sim1.updateRule()
    sim1.assignStates(x)
